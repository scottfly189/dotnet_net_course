1
00:00:01,400 --> 00:00:05,233
欢迎来到深入理解DotNet平台通讯实战课

2
00:00:05,300 --> 00:00:09,233
本课程是人工智能与微服务开发的网络基础课程

3
00:00:11,833 --> 00:00:22,000
本次课程让我们深入另外一种通讯机制,主要讲解S-S-E通讯机制，中文名也叫：服务端推送事件

4
00:00:22,400 --> 00:00:26,100
S-S-E 是基于HTTP协议的一种通讯机制

5
00:00:26,433 --> 00:00:37,900
目前在人工智能开发场合应用面比较广，本次课程我们最主要分两节课来透切讲解SSE前端与后端的原理

6
00:00:38,400 --> 00:00:44,400
并且包括S-S-E的前后端开发中的最佳实践

7
00:00:45,233 --> 00:00:47,900
那么，让我们开始我们的课程

8
00:00:51,200 --> 00:00:55,800
看这里，这里是S-S-E的一个架构图

9
00:00:56,000 --> 00:01:02,666
首先，由客户端或者浏览器向服务端发起一个HTTP请求

10
00:01:03,200 --> 00:01:13,266
服务端接收到这个HTTP请求后，会把此HTTP连接标识为长连接

11
00:01:14,000 --> 00:01:18,033
并标志为SSE的通讯机制

12
00:01:18,533 --> 00:01:19,400
也就是说

13
00:01:19,400 --> 00:01:23,333
按S-S-E的约定返回HTTP响应头

14
00:01:24,266 --> 00:01:25,200
然后

15
00:01:27,500 --> 00:01:30,500
如果服务端有数据产生

16
00:01:30,833 --> 00:01:35,266
就会复用同一个HTTP的连接发送数据

17
00:01:35,266 --> 00:01:41,633
如果服务端没有数据产生,连接就会阻塞在这里

18
00:01:41,800 --> 00:01:46,733
所以，S-S-E是服务端有数据产生才发送

19
00:01:46,933 --> 00:01:49,833
没有数据它就会阻塞

20
00:01:49,833 --> 00:01:50,866
特别注意一点

21
00:01:53,233 --> 00:02:00,033
SSE是服务端向客户端的单向数据流

22
00:02:01,233 --> 00:02:06,233
也就是说:客户端对服务端发起一次HTTP请求

23
00:02:06,333 --> 00:02:10,500
服务端可以根据需要多次向客户端发送数据

24
00:02:11,033 --> 00:02:16,633
并且，也仅是服务端向客户端发送数据

25
00:02:17,266 --> 00:02:18,066
所以

26
00:02:20,300 --> 00:02:23,900
SSE不是一种协议,它仅是一种通讯机制

27
00:02:24,033 --> 00:02:30,033
是客户端的一次HTTP请求，服务端多次发送数据的机制

28
00:02:30,100 --> 00:02:32,700
并且是一种轻量的、高效的

29
00:02:32,700 --> 00:02:38,333
基于HTTP协议的一种通讯机制

30
00:02:43,800 --> 00:02:48,800
为什么S-S-E通讯机制这么高效？

31
00:02:48,800 --> 00:02:59,400
因为S-S-E只建立一次TCP连接,后续连接直接复用这个连接,省去了大量的、重复的连接协议开销

32
00:02:59,466 --> 00:03:08,866
因为要重建TCP链接,要经历TCP握手、HTTP请求、解释等等过程

33
00:03:10,000 --> 00:03:13,833
这些都是一些"很重"的代价与开销

34
00:03:14,233 --> 00:03:20,933
第二:S-S-E是服务端有数据才发送,没数据就阻塞，降低了无意义的数据传输

35
00:03:21,500 --> 00:03:27,066
所以:与WebSocket、gRPC等协议相比

36
00:03:27,533 --> 00:03:31,066
S-S-E是纯文本的

37
00:03:31,066 --> 00:03:36,000
并且基于HTTP协议,不需要额外的协议切换

38
00:03:36,233 --> 00:03:40,000
而且也不需要把协议进行升级

39
00:03:40,200 --> 00:03:41,500
所以部署更简单

40
00:03:41,633 --> 00:03:46,500
特别适合于服务端单向推送数据到客户端的场合

41
00:03:49,533 --> 00:03:52,400
另外,S-S-E还有一个重要的机制

42
00:03:53,200 --> 00:03:56,933
就是天然具有自动重连机制,例如：

43
00:03:56,933 --> 00:04:04,100
如果发生网络异常而断线、或者服务器重启等等都可以自动重连

44
00:04:05,100 --> 00:04:10,533
当然,我们也可以通过心跳来实现自动重连的功能

45
00:04:11,866 --> 00:04:13,133
现在

46
00:04:13,133 --> 00:04:16,200
让我们认识一下SSE的通讯格式

47
00:04:17,000 --> 00:04:25,100
首先要知道：从服务端向客户端的S-S-E推送，它的数据格式是纯文本的

48
00:04:25,100 --> 00:04:28,900
通讯格式是Key-value键值对

49
00:04:29,300 --> 00:04:31,933
类似于HTTP Header格式

50
00:04:32,833 --> 00:04:34,800
第二、一条完整的消息

51
00:04:34,800 --> 00:04:38,433
必须以两个连续的换行符结束

52
00:04:40,633 --> 00:04:47,333
让我们用示例来观察一个真实的S-S-E通讯格式场景

53
00:04:51,900 --> 00:04:55,233
我们打开的这个网页，有很多通讯示例

54
00:04:55,533 --> 00:04:59,866
例如:这一条消息示例

55
00:05:00,033 --> 00:05:02,666
data冒号后面加消息体

56
00:05:03,433 --> 00:05:08,266
然后，一个完整的消息最后一定要放两个换行符来结束

57
00:05:08,266 --> 00:05:18,033
也就是:在服务端发送多条消息的场合,在最后一个消息，必须用两个换行符来结束

58
00:05:19,800 --> 00:05:21,300
另外要注意

59
00:05:23,200 --> 00:05:27,300
这里的键值对，可以用Event加上事件类型

60
00:05:27,300 --> 00:05:29,100
这个是可选的

61
00:05:29,233 --> 00:05:32,900
假如我们省略Event键值对

62
00:05:32,900 --> 00:05:39,900
相当于我们写了Event加上message事件类型

63
00:05:39,900 --> 00:05:42,133
另外的可选值是ID

64
00:05:42,133 --> 00:05:43,300
这个也是可选的

65
00:05:43,633 --> 00:05:47,000
最主要用于断点续传的场合

66
00:05:48,133 --> 00:05:50,466
下面是最重要的Data

67
00:05:51,133 --> 00:05:55,400
就是前面是data，后面是消息体的键值对

68
00:05:55,400 --> 00:06:07,400
我们在使用Data键值对的时候，后面的消息体最后一定要加上一个换行符做为结尾

69
00:06:08,266 --> 00:06:16,800
另外一条消息结束，我们必须要在消息体最后面加上两个换行符做为消息结束标识

70
00:06:18,466 --> 00:06:22,500
那么，我们用代码来实现一个S-S-E前端

71
00:06:27,266 --> 00:06:38,200
我们首先打开后端服务，这个后端服务我们课前已经实现，现在最主要是演示SSE前端

72
00:06:38,200 --> 00:06:39,500
让我们新建一个前端

73
00:06:43,533 --> 00:06:46,300
这次我们是新建一个Vue3的前端

74
00:06:57,266 --> 00:07:01,733
我们用cursor打开它

75
00:07:01,733 --> 00:07:14,066
我们先点击SRC目录,再点击App.Vue文件

76
00:07:15,033 --> 00:07:35,633
下一步我们要在App文件中操作，我们要先引入我们需要的VUE的模块,最主是onMounted与on-Unmounted两个函数

77
00:07:38,266 --> 00:07:42,733
由于我们在一个真实的开发场景中,我们要处理好鉴权

78
00:07:42,900 --> 00:07:45,733
并且还要处理好用户ID的问题

79
00:07:45,733 --> 00:07:54,000
在这里,我们将问题简化为用两个变量来模拟从客户端获取用户ID与用户的token

80
00:07:54,000 --> 00:07:58,600
然后通过S-S-E的机制把请求发送给服务端

81
00:08:22,733 --> 00:08:24,400
注意：在前端

82
00:08:24,400 --> 00:08:26,333
一般使用event source对象

83
00:08:26,466 --> 00:08:35,633
我们使用Event Source对象来向远程服务端发起S-S-E的请求

84
00:08:35,633 --> 00:08:39,200
所以我们需要新建一个Event Source对象

85
00:08:39,200 --> 00:08:47,733
并且把服务端的URL放在这个Event Source对象的参数列表里面

86
00:08:58,866 --> 00:09:00,466
我们把服务端的

87
00:09:00,466 --> 00:09:03,266
那个URL复制粘贴进来

88
00:09:17,433 --> 00:09:20,333
大家请注意看我鼠标的位置

89
00:09:20,333 --> 00:09:27,133
在这里，我们是将用户的Token放在URL的动态路径里

90
00:09:27,133 --> 00:09:32,600
并且把用户ID放在URL的请求参数Query中

91
00:09:32,600 --> 00:09:41,933
因为原因是：我们不能在Event Source对象中增加请求头,这点要特别注意

92
00:09:42,600 --> 00:09:48,100
所以我们只能将Token或者用户ID放在URL中传递

93
00:09:51,400 --> 00:10:14,133
然后，Event Source对象有三个属性,我将代码写一下,最主要是：open、error、message

94
00:10:14,233 --> 00:10:20,100
Event Source最主要有三个属性
第一个属性是onmessage

95
00:10:20,200 --> 00:10:22,000
第二个属性是on error

96
00:10:23,333 --> 00:10:27,500
还有一个属性是onopen

97
00:10:27,700 --> 00:10:35,233
当我们的SSE客户端连接成功服务端，客户端会触发on -open事件

98
00:10:36,900 --> 00:10:41,933
一旦连接成功,客户端就能收到服务端所发送过来消息

99
00:10:41,933 --> 00:10:45,600
这样就会触发onMessage事件

100
00:10:46,100 --> 00:10:47,733
如果有错误

101
00:10:47,733 --> 00:10:51,933
例如:发生网络故障或者服务端关闭

102
00:10:52,000 --> 00:10:57,600
那么EventSource的onerror事件就会触发

103
00:10:58,100 --> 00:11:08,866
让我们在页面装载完成事件中加上刚完成的init-SSE-Connection方法

104
00:11:08,866 --> 00:11:15,500
另外，我们还需要在SSE-Connectio这里加上一些防御性代码

105
00:11:16,200 --> 00:11:25,666
而且，我们还需要在页面被刷新或者被关闭的时候，运行EventSource的关闭方法

106
00:11:25,666 --> 00:11:34,266
也就是我们需要在onUnmounted方法中运行Event Source的关闭方法

107
00:11:37,466 --> 00:11:40,433
这样我们就完成了客户端的代码

108
00:11:40,433 --> 00:11:42,633
我们运行一下

109
00:11:42,633 --> 00:11:43,666
大家看这里

110
00:11:43,666 --> 00:11:48,666
我们转到工具栏的运行，再点击"运行和调试“按钮

111
00:11:52,100 --> 00:11:54,433
我们用命令启动前端应用

112
00:11:56,900 --> 00:12:00,733
对了，我们还需要修改一下实际的端口号

113
00:12:03,800 --> 00:12:06,133
让我们点击

114
00:12:06,133 --> 00:12:11,433
点击左上角的小三角，就是那个运行按钮

115
00:12:11,433 --> 00:12:13,933
开始调试运行应用

116
00:12:23,500 --> 00:12:27,700
这样，我们就成功打开了应用

117
00:12:27,700 --> 00:12:29,733
请随我转到下面区域

118
00:12:29,733 --> 00:12:32,900
最主要看一下"控制台”输出日志

119
00:12:36,300 --> 00:12:45,266
我们在这里可以看到应用的日志，这里显示了S-S-E连接成功的信息

120
00:12:46,000 --> 00:12:51,100
也可以看到onMessage也可以正常接收到消息

121
00:12:52,933 --> 00:12:56,333
大家还记得前面讲的内容吗？

122
00:12:57,400 --> 00:13:03,866
就是SSE天然的具有自动重连功能

123
00:13:03,866 --> 00:13:05,900
让我们测试一下

124
00:13:06,000 --> 00:13:09,333
我先关掉服务端来模拟一个异常

125
00:13:14,400 --> 00:13:16,400
我已经关掉了服务端

126
00:13:19,633 --> 00:13:22,466
大家观察一下前端的控制台

127
00:13:22,466 --> 00:13:27,733
这里预料中的提示出错，因为我把服务端关了

128
00:13:27,733 --> 00:13:29,833
然后,我再打开服务端

129
00:13:38,000 --> 00:13:40,133
我先清掉控制台日志

130
00:13:46,833 --> 00:13:56,500
在这里的控制台，显示连接成功，并且能正常接收服务端发送消息

131
00:13:56,600 --> 00:14:01,466
当然，我们还有一种更好的方式接收数据

132
00:14:01,600 --> 00:14:08,266
刚才的代码，我们是用普通方式来接收服务端数据的

133
00:14:08,266 --> 00:14:14,433
现在让我们改成一种更好的以事件的方式来接收数据

134
00:14:14,433 --> 00:14:17,700
我们先把先前的代码注释

135
00:14:17,700 --> 00:14:19,100
也把客户端断开

136
00:14:24,300 --> 00:14:26,433
我们先把老代码注释

137
00:14:30,666 --> 00:14:34,933
我们改成以事件的方式来接收服务端数据

138
00:14:42,433 --> 00:14:46,700
我们使用add Event Listener这个方法

139
00:14:46,700 --> 00:14:49,033
这里要写事件名称

140
00:14:49,700 --> 00:14:55,200
后面是事件的回调，这里最主要是event对象

141
00:14:57,033 --> 00:15:00,766
我们现在可以用命令的方式再运行一下

142
00:15:17,533 --> 00:15:21,466
大家看：日志显示的结果与之前一模一样

143
00:15:21,466 --> 00:15:34,333
这里表明：我们可以通过add Event Listener方法，以事件的方式接收服务端消息

144
00:15:34,433 --> 00:15:37,600
让我们再进一步观察一下

145
00:15:40,500 --> 00:15:42,266
右键点击检查菜单

146
00:15:44,400 --> 00:15:52,433
然后点击Console页面，再点击Network标签页

147
00:15:54,233 --> 00:15:56,266
我现在重新刷新一下

148
00:15:56,300 --> 00:16:00,733
看这里:尽管一直有数据返回，但这里仅有一个请求

149
00:16:01,000 --> 00:16:02,500
所以:也强调一下

150
00:16:02,500 --> 00:16:12,833
就是SSE传输模式，它是客户端向服务端发起一次请求,但是服务端可以多次向客户端返回数据

151
00:16:14,933 --> 00:16:21,466
让我们看一下S-S-E真实的请求头

152
00:16:21,466 --> 00:16:23,700
大家看这里

153
00:16:24,133 --> 00:16:28,533
这里有一个Accept请求头

154
00:16:29,000 --> 00:16:40,266
它的含义是：我希望服务端返回text/event-stream的消息类型

155
00:16:41,333 --> 00:16:48,533
相应的，让我们再看看S-S-E服务端的返回响应头

156
00:16:49,733 --> 00:16:51,400
大家看这里

157
00:16:51,433 --> 00:17:03,166
在服务端响应这里，它正确的返回了客户端期望的text/event-stream的Content-Type

158
00:17:04,100 --> 00:17:05,933
我们再看Preview页面

159
00:17:11,100 --> 00:17:12,600
大家看到没有？

160
00:17:12,600 --> 00:17:13,633
看这里

161
00:17:13,633 --> 00:17:17,000
所以我再做一次强调

162
00:17:17,000 --> 00:17:19,833
客户端的一次HTTP请求

163
00:17:19,833 --> 00:17:29,100
服务端可以多次发送数据给客户端，直到客户端关闭

164
00:17:29,100 --> 00:17:30,833
我们再看一下代码段

165
00:17:34,833 --> 00:17:41,266
刚才我们已经改成以事件的方式来接受服务端的返回

166
00:17:41,700 --> 00:17:43,600
当然，我们还可以

167
00:17:43,700 --> 00:17:46,066
加上我们的自定义事件

168
00:17:46,066 --> 00:17:48,333
这是实际开发中更常见的做法

169
00:18:16,800 --> 00:18:17,900
我们测试一下

170
00:18:20,500 --> 00:18:31,300
大家看控制台，我刚才加上的心跳事件也正常接收，控制台这里打印了心跳信息

171
00:18:32,933 --> 00:18:48,500
我再优化一下

172
00:18:48,500 --> 00:18:49,466
大家看下面

173
00:18:50,033 --> 00:18:52,933
我先清除一下控制台

174
00:18:53,866 --> 00:18:54,666
你看这里

175
00:18:55,133 --> 00:19:00,500
控制台的显示表明正确的打印了心跳消息

176
00:19:02,333 --> 00:19:12,866
用这种方式，我们可以跟服务端自由的约定事件名，并且在客户端加上自定义事件的处理程序

177
00:19:15,866 --> 00:19:19,700
让我们再深入理解一下EventSource

178
00:19:19,933 --> 00:19:31,033
在客户端我们最常用的是使用Event Source对象来接收服务端的返回数据

179
00:19:32,533 --> 00:19:35,433
Event Source对象有三个关键事件

180
00:19:35,433 --> 00:19:42,400
第一个事件是客户端连接服务端成功后的on open事件

181
00:19:42,733 --> 00:19:49,300
第二个事件是发生错误后的on error事件

182
00:19:49,300 --> 00:19:57,133
第三个事件是服务端发送消息触发的on message事件，也是默认事件的消息触发器

183
00:19:58,666 --> 00:20:00,066
就是说

184
00:20:00,066 --> 00:20:08,200
如果我们在写程序的时候,省略了event的键值对，则默认是event:message

185
00:20:08,533 --> 00:20:13,966
最后我们可以通过add Event Listener接收自定义事件

186
00:20:14,133 --> 00:20:17,900
EventSource的方法有三个

187
00:20:17,900 --> 00:20:20,700
第一个就是我们刚才我们用过的

188
00:20:20,866 --> 00:20:26,300
最重要的add Event Listener方法

189
00:20:26,333 --> 00:20:32,266
这个主要用来监听服务端发来自定义事件消息

190
00:20:32,266 --> 00:20:35,566
第二个是remove-event-Listener方法

191
00:20:35,700 --> 00:20:40,400
这个是移除事件监听

192
00:20:40,400 --> 00:20:46,600
第三个是close方法，也就是关闭EventSource对象

193
00:20:46,800 --> 00:20:54,266
然后EventSource对象还有三个属性

194
00:20:54,500 --> 00:20:58,833
一个是ready state属性,代表连接状态

195
00:20:58,833 --> 00:21:00,600
状态值有三种

196
00:21:00,600 --> 00:21:02,333
我们等下再深入

197
00:21:02,333 --> 00:21:04,200
第二个是URL属性

198
00:21:04,233 --> 00:21:08,600
这个就是EventSource连接的地址

199
00:21:08,600 --> 00:21:13,533
还有一个是with Credentials属性

200
00:21:13,666 --> 00:21:28,700
这个最主要用在跨源场合,如果设置为true,则自动发送cookie信息，否则默认只有同源才自动发送

201
00:21:36,000 --> 00:21:39,733
我们再深入EventSource的状态

202
00:21:39,733 --> 00:21:45,266
EventSource的状态值最主要有三种

203
00:21:45,266 --> 00:21:49,066
第一个是CONNECTING

204
00:21:49,100 --> 00:21:56,400
它的含义是尝试连接或者正在连接状态，它的状态值为:0

205
00:21:57,100 --> 00:22:03,666
第二个是OPEN状态，表示连接已建立，可以正常接收数据，状态值为1

206
00:22:04,700 --> 00:22:16,400
第三个是CLOSED状态，如果我们运行了Close命令，
EventSource就处于这种状态,状态值是2

207
00:22:18,400 --> 00:22:25,400
看这里，这里是EventSource的一个状态机的图,让我详细说一下

208
00:22:25,500 --> 00:22:37,500
在EventSource刚创建连接，或者正在连接途中，就是这种CONNECTING状态,它的value值为0

209
00:22:38,300 --> 00:22:45,800
如果连接成功，它就从Connecting状态转变到Open状态，它的状态值是1

210
00:22:45,800 --> 00:22:58,066
另外，如果发生网络故障，或者服务器关闭，大家知道S-S-E有进行自动重连的机制

211
00:22:58,666 --> 00:23:09,733
EventSource会从OPEN状态重新进入CONNECTING状态，然后自动发起重连

212
00:23:09,733 --> 00:23:18,033
这个时候有两种情况，如果重连成功，EventSource会自动的从CONNECTING状态转变为OPEN状态

213
00:23:18,500 --> 00:23:25,400
如果我们Close了，EventSource就会变成CLOSED状态

214
00:23:26,200 --> 00:23:30,200
那么，重要的内容来了

215
00:23:30,400 --> 00:23:42,300
第一、EventSource是受跨源限制的，所以服务器端必须要实现CORS,也就是允许跨源

216
00:23:45,933 --> 00:23:46,833
第二个

217
00:23:47,133 --> 00:23:50,400
因为EventSource不能发送请求头

218
00:23:50,800 --> 00:23:52,666
如果需要身份验证

219
00:23:52,800 --> 00:23:57,033
我们需要把token放在URL的参数中

220
00:23:57,466 --> 00:24:00,466
这也是JWT鉴权的方式

221
00:24:00,533 --> 00:24:04,900
如果基于服务器Cookie-Session的鉴权

222
00:24:05,000 --> 00:24:18,433
EventSource发送请求的时候，使用withCredentials属性，并且设置为true,这样就能自动发送Cookie与Http认证

223
00:24:18,433 --> 00:24:25,933
好的，这个就是S-S-E前端的讲解,大家透彻理解了吧？

224
00:24:26,033 --> 00:24:31,300
另外，大家可以阅读一下S-S-E的官方规范

225
00:24:31,300 --> 00:24:37,866
就是这个网页，做为官方的网页，他很详细讲解了SSE规范

226
00:24:37,866 --> 00:24:44,300
特别要认真学习一下通讯格式与状态变化等

227
00:24:47,866 --> 00:24:51,433
好的，我给大家预告一下下节课的内容

228
00:24:51,433 --> 00:24:57,133
刚才我们了解了客户端，下节课最主要讲解SSE服务端的开发

229
00:25:00,133 --> 00:25:02,466
好的，时间过得很快

230
00:25:02,666 --> 00:25:10,433
大家休息一下，然后我们继续下面的课程

